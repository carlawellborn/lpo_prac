-----------------------------------------------------------------------------
      name:  <unnamed>
       log:  /Users/doylewr/lpo_prac/lessons/s1-04-dataset_manipulation/datas
> et_manipulation.log
  log type:  text
 opened on:  16 Sep 2020, 10:42:31

. 
. // NAME: Dataset manipulation
. // FILE: dataset_manipulation.do
. // AUTH: Will Doyle
. // REVS: Benjamin Skinner
. // INIT: 9 September 2012
. // LAST: 16 Sep 2020
. 
. clear all                               // clear memory

. 
. 
. //Data import
. 
. import delimited "https://stats.idre.ucla.edu/wp-content/uploads/2016/02/hs
> b2-2.csv", clear
(11 vars, 200 obs)

.  
. // Excel
. 
. import excel "tabn304.10.xls", cellrange(A5:L64) clear
(12 vars, 60 obs)

. 
. // set globals for url data link and local data path
. global urldata "https://stats.idre.ucla.edu/stat/stata/seminars/svy_stata_i
> ntro/apipop"

. 
. // read web data into memory
. use $urldata, clear

. 
. 
. /***
> Subsetting with {c 96}preserve{c 96} and {c 96}restore{c 96} 
> ----------------------------------------
> 
> A feature and sometimes curse of Stata is that it can only hold one dataset
>  in active memory at a time. As a feature, it helps you keep your work orga
> nized and, through numerous warning messages, tries to make sure you don't 
> lose your work by accidentally forgetting to save or mindlessly overwrittin
> g your data. The feature feels more like a curse when you have multiple dat
> asets that you would like to work with simultaneously or, as we will do bel
> ow, split a single dataset into smaller parts.
> 
> To repeatedly subset a large dataset, there are two primary choices:
> 1. Reload the full dataset into memory after each subset and save
> 2. Use the {c 96}preserve{c 96} and {c 96}restore{c 96} commands
> 
> In the code below, notice how the {c 96}preserve{c 96} and {c 96}restore{c 
> 96} commands bookend the {c 96}keep{c 96} command, which keeps only those o
> bservations that fulfill the {c 96}if{c 96} statement (in this case, the ty
> pe of school). The steps are:
> 1. preserve dataset in memory
> 2. subset to keep only school type that we want
> 3. save new subset dataset
> 4. restore old dataset
> ***/
. 
. 
. // split into three datasets: elementary, middle, and high school
. 
. // -1- preserve dataset in memory
. // -2- subset to keep only school type that we want
. // -3- save new subset dataset
. // -4- restore old dataset
. 
. // elementary schools
. preserve

. keep if stype == 1    
(1,773 observations deleted)

. tab stype 

      stype |      Freq.     Percent        Cum.
------------+-----------------------------------
          E |      4,421      100.00      100.00
------------+-----------------------------------
      Total |      4,421      100.00

.                  
. save elem, replace
file elem.dta saved

. restore

. 
. // high schools
. preserve

. keep if stype == 2                      
(5,439 observations deleted)

. save hs, replace
file hs.dta saved

. restore

. 
. // middle schools (keep this one in memory so no preserve/restore needed)
. keep if stype == 3                      
(5,176 observations deleted)

. save middle, replace
file middle.dta saved

. 
. /***
> Appending Data
> --------------
> 
> Appending data is done when we want to add additional *observations* to an 
> existing dataset, using a dataset that has exactly the same variable names 
> but different observations. Suppose you have data on high schools, middle s
> chools, and elementary schools on a variety of performance indicators and y
> ou'd like to merge them together. The syntax uses, appropriately enough, th
> e {c 96}append{c 96} command, which takes the format {c 96}append <new data
> set>{c 96} (the command assumes the first dataset is the one in memory; rem
> ember that the middle school subset data are still in memory):
> ***/
. 
. // merging via the append command
. append using elem   
(label yr_rnd already defined)
(label awards already defined)
(label both already defined)
(label comp_imp already defined)
(label sch_wide already defined)
(label stype already defined)

. append using hs
(label stype already defined)
(label sch_wide already defined)
(label comp_imp already defined)
(label both already defined)
(label awards already defined)
(label yr_rnd already defined)

. 
. 
. /*** 
> The `append` command will not copy over labels from the using dataset, so y
> ou'll need to make sure they're right in the master dataset. The most commo
> n error with an append command is to not have exactly matching variable nam
> es.
> ***/
. 
. /***
> Merging Data
> ------------
> 
> You can also use Stata's {c 96}merge{c 96} command to do an append operatio
> n in special cases. This happens when the merging variable doesn't have rep
> eated *observations* in the two datasets, which in turn have exactly the sa
> me variable structure. Think of a Venn diagram where the circles contain ex
> actly the same types of information, but don't overlap; in combining them, 
> we've really just grown them into one bigger circle. One of the virtues of 
> using {c 96}merge{c 96} when {c 96}append{c 96} will suffice is that you ha
> ve access to more information about where the data came from once you're do
> ne.
> ***/
. 
.  
. // merging via the merge command
. 
. use elem, clear

. 
. merge 1:1 snum using hs, gen(_merge_a)
(label yr_rnd already defined)
(label awards already defined)
(label both already defined)
(label comp_imp already defined)
(label sch_wide already defined)
(label stype already defined)

    Result                           # of obs.
    -----------------------------------------
    not matched                         5,176
        from master                     4,421  (_merge_a==1)
        from using                        755  (_merge_a==2)

    matched                                 0  (_merge_a==3)
    -----------------------------------------

. 
. merge 1:1 snum using middle, gen(_merge_b)
(label stype already defined)
(label sch_wide already defined)
(label comp_imp already defined)
(label both already defined)
(label awards already defined)
(label yr_rnd already defined)

    Result                           # of obs.
    -----------------------------------------
    not matched                         6,194
        from master                     5,176  (_merge_b==1)
        from using                      1,018  (_merge_b==2)

    matched                                 0  (_merge_b==3)
    -----------------------------------------

. 
. /***
> Once you've completed the merge, you can take a look at the \_merge\_\* var
> iables that were generated to see where the data came from.
> ***/
. 
. 
. 
. 
. // show merge stats for each merge
. tab _merge_a

               _merge_a |      Freq.     Percent        Cum.
------------------------+-----------------------------------
        master only (1) |      4,421       85.41       85.41
         using only (2) |        755       14.59      100.00
------------------------+-----------------------------------
                  Total |      5,176      100.00

. tab _merge_b

               _merge_b |      Freq.     Percent        Cum.
------------------------+-----------------------------------
        master only (1) |      5,176       83.56       83.56
         using only (2) |      1,018       16.44      100.00
------------------------+-----------------------------------
                  Total |      6,194      100.00

. 
. 
. /* Quick Exercise: Create a dataset that has just middle and elementary sch
> ools.
>  Do this using first the append command and then the merge command.*/
.  
.  // Elementary schools in memory
.  use elem, clear

.  
.  append using middle
(label yr_rnd already defined)
(label awards already defined)
(label both already defined)
(label comp_imp already defined)
(label sch_wide already defined)
(label stype already defined)

.  
.  use elem, clear

.  
.  merge 1:1 snum using middle, nogen
(label stype already defined)
(label sch_wide already defined)
(label comp_imp already defined)
(label both already defined)
(label awards already defined)
(label yr_rnd already defined)

    Result                           # of obs.
    -----------------------------------------
    not matched                         5,439
        from master                     4,421  
        from using                      1,018  

    matched                                 0  
    -----------------------------------------

. 
. /***
> One-to-one merges
> -----------------
> 
> A one-to-one merge is when you have exactly the same *observations* but new
>  variables to add to the dataset. Say you have *observations* with variable
> s split across datasets, e.g., School 1 has variables A, B, and C in datase
> t 1 and variables X, Y, and Z in dataset two. As long as School 1 has a uni
> que identifier---a name, an id number, etc---you can {c 96}merge{c 96} thes
> e two datasets together so that you have access to all of the school's vari
> ables for your analysis.
> 
> First, we need to subset our data again, only this time by splitting along 
> columns (*variables*) rather than rows (*observations*):
> ***/
. 
. 
. // split dataset by variables
. use $urldata, clear

. 
. preserve

. keep snum api00 api99 ell meals         // variable set 1

. save api_1, replace
file api_1.dta saved

. restore

. keep snum full emer                     // variable set 2

. save api_2, replace
file api_2.dta saved

. 
. 
. // merging back together (api_2 in memory)
. merge 1:1 snum using api_1

    Result                           # of obs.
    -----------------------------------------
    not matched                             0
    matched                             6,194  (_merge==3)
    -----------------------------------------

. 
. // view merge stats
. tab _merge

                 _merge |      Freq.     Percent        Cum.
------------------------+-----------------------------------
            matched (3) |      6,194      100.00      100.00
------------------------+-----------------------------------
                  Total |      6,194      100.00

. 
. // collapsing data
. 
. // reload main dataset, since we didn't preserve it before
. use $urldata, clear

. 
. 
. /***
> *QUICK EXERCISE
> Create a dataset that has only mobility and percent tested. Next create ano
> ther dataset that has only the year round and percent responding variables.
>  Now merge these two datasets together using a one-to-one merge.*
> ***/
. 
. 
. /***
> Collapsing data
> ---------------
> 
> Collapsing data refers to summarizing data across a type and creating a new
>  dataset as a result. Say we want to create a county-level dataset from our
>  school data, using the average figures for the schools across a set of cha
> racteristics. The command would look like this:
> 
> ***/
. 
. // count of unique counties in dataset
. unique cnum
Number of unique values of cnum is  57
Number of records is  6194

. 
. preserve

. // mean of pcttest and mobility within countyr
. collapse (mean) pcttest mobility, by (cnum)

. restore

. 
. // Total enrollment by district
. 
. collapse (sum) district_enroll=enroll, by(dnum)

. 
. save district_enroll, replace
file district_enroll.dta saved

. 
. use $urldata, clear

. 
. merge m:1 dnum using district_enroll

    Result                           # of obs.
    -----------------------------------------
    not matched                             0
    matched                             6,194  (_merge==3)
    -----------------------------------------

.  
. // give count of number of observations (should be number of unique countie
> s)
. count
  6,194

. 
. /***
> QUICK EXERCISE
> Create a district level dataset that contains district level averages for t
> he following variables:
> 
> -apioo
> -api99
> -ell
> -meals 
> 
> Then do the same thing using just district medians.
> 
> ***/
. 
. // end file
. log close                               // close log
      name:  <unnamed>
       log:  /Users/doylewr/lpo_prac/lessons/s1-04-dataset_manipulation/datas
> et_manipulation.log
  log type:  text
 closed on:  16 Sep 2020, 10:42:37
-----------------------------------------------------------------------------
